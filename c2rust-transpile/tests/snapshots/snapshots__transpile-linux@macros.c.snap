---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/os-specific/macros.linux.rs
input_file: c2rust-transpile/tests/snapshots/os-specific/macros.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    path_statements,
    unsafe_op_in_unsafe_fn,
    unused_assignments,
    unused_mut,
    unused_unsafe,
    unused_variables
)]
use core::ffi;
unsafe extern "C" {
    fn __errno_location() -> *mut ffi::c_int;
    fn memcpy(__dest: *mut ffi::c_void, __src: *const ffi::c_void, __n: size_t)
    -> *mut ffi::c_void;
}
pub type size_t = usize;
#[unsafe(no_mangle)]
pub unsafe extern "C" fn errno_is_error() -> bool {
    return *__errno_location() != 0 as ffi::c_int;
}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn size_of_const() -> ffi::c_int {
    let mut a: [ffi::c_int; 10] = [0; 10];
    return SIZE as ffi::c_int;
}
pub const SIZE: usize = ::core::mem::size_of::<[ffi::c_int; 10]>();
pub const POS: [ffi::c_char; 3] =
    unsafe { ::core::mem::transmute::<[u8; 3], [ffi::c_char; 3]>(*b"\"]\0") };
#[unsafe(no_mangle)]
pub unsafe extern "C" fn memcpy_str_literal(mut out: *mut ffi::c_char) {
    memcpy(
        out as *mut ffi::c_void,
        c"\"]".as_ptr() as *const ffi::c_void,
        (::core::mem::size_of::<[ffi::c_char; 3]>() as size_t)
            .wrapping_div(::core::mem::size_of::<ffi::c_char>() as size_t)
            .wrapping_sub(1 as size_t)
            .wrapping_add(1 as size_t)
            .wrapping_mul(::core::mem::size_of::<ffi::c_char>() as size_t),
    );
}
