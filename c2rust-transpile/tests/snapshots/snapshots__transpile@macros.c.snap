---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/macros.rs
input_file: c2rust-transpile/tests/snapshots/macros.c
---
#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
use core::ffi;
extern "C" {
    fn extern_fn() -> ffi::c_int;
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct S {
    pub i: ffi::c_int,
}
pub type U64 = ffi::c_ulonglong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fn_ptrs {
    pub v: *mut ffi::c_void,
    pub fn1: Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub fn2: Option<unsafe extern "C" fn(ffi::c_int) -> ffi::c_int>,
}
pub type zstd_platform_dependent_type = ffi::c_long;
pub const NESTED_INT: ffi::c_int = 0xffff as ffi::c_int;
#[no_mangle]
pub unsafe extern "C" fn local_muts() {
    let mut literal_int: ffi::c_int = 0xffff as ffi::c_int;
    let mut literal_bool: bool = 1 as ffi::c_int != 0;
    let mut literal_float: ffi::c_float = 3.14f32;
    let mut literal_char: ffi::c_char = 'x' as i32 as ffi::c_char;
    let mut literal_str_ptr: *const ffi::c_char =
        b"hello\0" as *const u8 as *const ffi::c_char;
    let mut literal_str: [ffi::c_char; 6] =
        *::core::mem::transmute::<&[u8; 6], &mut [ffi::c_char; 6]>(b"hello\0");
    let mut literal_array: [ffi::c_int; 3] = [
        1 as ffi::c_int,
        2 as ffi::c_int,
        3 as ffi::c_int,
    ];
    let mut literal_struct: S = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    };
    let mut nested_int: ffi::c_int = NESTED_INT;
    let mut nested_bool: bool = 1 as ffi::c_int != 0;
    let mut nested_float: ffi::c_float = 3.14f32;
    let mut nested_char: ffi::c_char = 'x' as i32 as ffi::c_char;
    let mut nested_str_ptr: *const ffi::c_char =
        b"hello\0" as *const u8 as *const ffi::c_char;
    let mut nested_str: [ffi::c_char; 6] =
        *::core::mem::transmute::<&[u8; 6], &mut [ffi::c_char; 6]>(b"hello\0");
    let mut nested_array: [ffi::c_int; 3] = [
        1 as ffi::c_int,
        2 as ffi::c_int,
        3 as ffi::c_int,
    ];
    let mut nested_struct: S = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    };
    let mut int_arithmetic: ffi::c_int =
        NESTED_INT + 0xffff as ffi::c_int + 1 as ffi::c_int;
    let mut mixed_arithmetic: ffi::c_float = (0xffff as ffi::c_int as ffi::c_double
        + 3.14f64 * 'x' as i32 as ffi::c_double
        - 1 as ffi::c_int as ffi::c_double)
        as ffi::c_float;
    let mut parens: ffi::c_int =
        0xffff as ffi::c_int * ('x' as i32 + 1 as ffi::c_int);
    let mut ptr_arithmetic: *const ffi::c_char = (b"hello\0" as *const u8
        as *const ffi::c_char)
        .offset(5 as ffi::c_int as isize)
        .offset(-(3 as ffi::c_int as isize));
    let mut widening_cast: ffi::c_ulonglong =
        0xffff as ffi::c_int as ffi::c_ulonglong;
    let mut narrowing_cast: ffi::c_char = 0xffff as ffi::c_int as ffi::c_char;
    let mut conversion_cast: ffi::c_double = 0xffff as ffi::c_int as ffi::c_double;
    let mut indexing: ffi::c_char =
        (*::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0"))
            [3.14f64 as ffi::c_int as usize];
    let mut str_concatenation_ptr: *const ffi::c_char =
        b"hello hello world\0" as *const u8 as *const ffi::c_char;
    let mut str_concatenation: [ffi::c_char; 18] =
        *::core::mem::transmute::<&[u8; 18], &mut [ffi::c_char; 18]>(b"hello hello world\0");
    let mut ref_indexing: *const ffi::c_char =
        &*(b"hello\0" as *const u8 as *const ffi::c_char)
            .offset(3.14f64 as ffi::c_int as isize) as *const ffi::c_char;
    let mut ref_struct: *const S = &mut {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    } as *mut S;
    let mut ternary: ffi::c_int = if 1 as ffi::c_int != 0 {
        1 as ffi::c_int
    } else {
        2 as ffi::c_int
    };
    let mut member: ffi::c_int = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    }
    .i;
}
#[no_mangle]
pub unsafe extern "C" fn local_consts() {
    let literal_int: ffi::c_int = 0xffff as ffi::c_int;
    let literal_bool: bool = 1 as ffi::c_int != 0;
    let literal_float: ffi::c_float = 3.14f32;
    let literal_char: ffi::c_char = 'x' as i32 as ffi::c_char;
    let literal_str_ptr: *const ffi::c_char =
        b"hello\0" as *const u8 as *const ffi::c_char;
    let literal_str: [ffi::c_char; 6] =
        *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0");
    let literal_array: [ffi::c_int; 3] = [
        1 as ffi::c_int,
        2 as ffi::c_int,
        3 as ffi::c_int,
    ];
    let literal_struct: S = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    };
    let nested_int: ffi::c_int = 0xffff as ffi::c_int;
    let nested_bool: bool = 1 as ffi::c_int != 0;
    let nested_float: ffi::c_float = 3.14f32;
    let nested_char: ffi::c_char = 'x' as i32 as ffi::c_char;
    let nested_str_ptr: *const ffi::c_char =
        b"hello\0" as *const u8 as *const ffi::c_char;
    let nested_str: [ffi::c_char; 6] =
        *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0");
    let nested_array: [ffi::c_int; 3] = [
        1 as ffi::c_int,
        2 as ffi::c_int,
        3 as ffi::c_int,
    ];
    let nested_struct: S = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    };
    let int_arithmetic: ffi::c_int =
        0xffff as ffi::c_int + 0xffff as ffi::c_int + 1 as ffi::c_int;
    let mixed_arithmetic: ffi::c_float = (0xffff as ffi::c_int as ffi::c_double
        + 3.14f64 * 'x' as i32 as ffi::c_double
        - 1 as ffi::c_int as ffi::c_double)
        as ffi::c_float;
    let parens: ffi::c_int = 0xffff as ffi::c_int * ('x' as i32 + 1 as ffi::c_int);
    let ptr_arithmetic: *const ffi::c_char = (b"hello\0" as *const u8
        as *const ffi::c_char)
        .offset(5 as ffi::c_int as isize)
        .offset(-(3 as ffi::c_int as isize));
    let widening_cast: ffi::c_ulonglong = 0xffff as ffi::c_int as ffi::c_ulonglong;
    let narrowing_cast: ffi::c_char = 0xffff as ffi::c_int as ffi::c_char;
    let conversion_cast: ffi::c_double = 0xffff as ffi::c_int as ffi::c_double;
    let indexing: ffi::c_char =
        (*::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0"))
            [3.14f64 as ffi::c_int as usize];
    let str_concatenation_ptr: *const ffi::c_char =
        b"hello hello world\0" as *const u8 as *const ffi::c_char;
    let str_concatenation: [ffi::c_char; 18] =
        *::core::mem::transmute::<&[u8; 18], &[ffi::c_char; 18]>(b"hello hello world\0");
    let ref_indexing: *const ffi::c_char =
        &*(b"hello\0" as *const u8 as *const ffi::c_char)
            .offset(3.14f64 as ffi::c_int as isize) as *const ffi::c_char;
    let ref_struct: *const S = &mut {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    } as *mut S;
    let ternary: ffi::c_int = if 1 as ffi::c_int != 0 {
        1 as ffi::c_int
    } else {
        2 as ffi::c_int
    };
    let member: ffi::c_int = {
        let mut init = S {
            i: 5 as ffi::c_int,
        };
        init
    }
    .i;
}
static mut global_static_const_literal_int: ffi::c_int = 0xffff as ffi::c_int;
static mut global_static_const_literal_bool: bool = 1 as ffi::c_int != 0;
static mut global_static_const_literal_float: ffi::c_float = 3.14f32;
static mut global_static_const_literal_char: ffi::c_char = 'x' as i32 as ffi::c_char;
static mut global_static_const_literal_str_ptr: *const ffi::c_char =
    b"hello\0" as *const u8 as *const ffi::c_char;
static mut global_static_const_literal_str: [ffi::c_char; 6] =
    unsafe { *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0") };
static mut global_static_const_literal_array: [ffi::c_int; 3] = [
    1 as ffi::c_int,
    2 as ffi::c_int,
    3 as ffi::c_int,
];
static mut global_static_const_literal_struct: S = {
    let mut init = S { i: 5 };
    init
};
static mut global_static_const_nested_int: ffi::c_int = 0xffff as ffi::c_int;
static mut global_static_const_nested_bool: bool = 1 as ffi::c_int != 0;
static mut global_static_const_nested_float: ffi::c_float = 3.14f32;
static mut global_static_const_nested_char: ffi::c_char = 'x' as i32 as ffi::c_char;
static mut global_static_const_nested_str_ptr: *const ffi::c_char =
    b"hello\0" as *const u8 as *const ffi::c_char;
static mut global_static_const_nested_str: [ffi::c_char; 6] =
    unsafe { *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0") };
static mut global_static_const_nested_array: [ffi::c_int; 3] = [
    1 as ffi::c_int,
    2 as ffi::c_int,
    3 as ffi::c_int,
];
static mut global_static_const_nested_struct: S = {
    let mut init = S { i: 5 };
    init
};
static mut global_static_const_int_arithmetic: ffi::c_int =
    0xffff as ffi::c_int + 0xffff as ffi::c_int + 1 as ffi::c_int;
static mut global_static_const_mixed_arithmetic: ffi::c_float =
    (0xffff as ffi::c_int as ffi::c_double + 3.14f64 * 'x' as i32 as ffi::c_double
        - 1 as ffi::c_int as ffi::c_double) as ffi::c_float;
static mut global_static_const_parens: ffi::c_int =
    0xffff as ffi::c_int * ('x' as i32 + 1 as ffi::c_int);
static mut global_static_const_ptr_arithmetic: *const ffi::c_char =
    0 as *const ffi::c_char;
static mut global_static_const_widening_cast: ffi::c_ulonglong =
    0xffff as ffi::c_int as ffi::c_ulonglong;
static mut global_static_const_narrowing_cast: ffi::c_char =
    0xffff as ffi::c_int as ffi::c_char;
static mut global_static_const_conversion_cast: ffi::c_double =
    0xffff as ffi::c_int as ffi::c_double;
static mut global_static_const_indexing: ffi::c_char = 0;
static mut global_static_const_str_concatenation_ptr: *const ffi::c_char =
    b"hello hello world\0" as *const u8 as *const ffi::c_char;
static mut global_static_const_str_concatenation: [ffi::c_char; 18] = unsafe {
    *::core::mem::transmute::<&[u8; 18], &[ffi::c_char; 18]>(b"hello hello world\0")
};
static mut global_static_const_ref_indexing: *const ffi::c_char = 0 as *const ffi::c_char;
static mut global_static_const_ref_struct: *const S = &{
    let mut init = S { i: 5 };
    init
} as *const S as *mut S;
static mut global_static_const_ternary: ffi::c_int = 0;
static mut global_static_const_member: ffi::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn global_static_consts() {}
#[no_mangle]
pub static mut global_const_literal_int: ffi::c_int = 0xffff as ffi::c_int;
#[no_mangle]
pub static mut global_const_literal_bool: bool = 1 as ffi::c_int != 0;
#[no_mangle]
pub static mut global_const_literal_float: ffi::c_float = 3.14f32;
#[no_mangle]
pub static mut global_const_literal_char: ffi::c_char = 'x' as i32 as ffi::c_char;
#[no_mangle]
pub static mut global_const_literal_str_ptr: *const ffi::c_char =
    b"hello\0" as *const u8 as *const ffi::c_char;
#[no_mangle]
pub static mut global_const_literal_str: [ffi::c_char; 6] =
    unsafe { *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0") };
#[no_mangle]
pub static mut global_const_nested_int: ffi::c_int = 0xffff as ffi::c_int;
#[no_mangle]
pub static mut global_const_nested_bool: bool = 1 as ffi::c_int != 0;
#[no_mangle]
pub static mut global_const_nested_float: ffi::c_float = 3.14f32;
#[no_mangle]
pub static mut global_const_nested_char: ffi::c_char = 'x' as i32 as ffi::c_char;
#[no_mangle]
pub static mut global_const_nested_str_ptr: *const ffi::c_char =
    b"hello\0" as *const u8 as *const ffi::c_char;
#[no_mangle]
pub static mut global_const_nested_str: [ffi::c_char; 6] =
    unsafe { *::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0") };
#[no_mangle]
pub static mut global_const_int_arithmetic: ffi::c_int =
    0xffff as ffi::c_int + 0xffff as ffi::c_int + 1 as ffi::c_int;
#[no_mangle]
pub static mut global_const_mixed_arithmetic: ffi::c_float =
    (0xffff as ffi::c_int as ffi::c_double + 3.14f64 * 'x' as i32 as ffi::c_double
        - 1 as ffi::c_int as ffi::c_double) as ffi::c_float;
#[no_mangle]
pub static mut global_const_parens: ffi::c_int =
    0xffff as ffi::c_int * ('x' as i32 + 1 as ffi::c_int);
#[no_mangle]
pub static mut global_const_ptr_arithmetic: *const ffi::c_char = 0 as *const ffi::c_char;
#[no_mangle]
pub static mut global_const_widening_cast: ffi::c_ulonglong =
    0xffff as ffi::c_int as ffi::c_ulonglong;
#[no_mangle]
pub static mut global_const_narrowing_cast: ffi::c_char =
    0xffff as ffi::c_int as ffi::c_char;
#[no_mangle]
pub static mut global_const_conversion_cast: ffi::c_double =
    0xffff as ffi::c_int as ffi::c_double;
#[no_mangle]
pub static mut global_const_indexing: ffi::c_char = 0;
#[no_mangle]
pub static mut global_const_str_concatenation_ptr: *const ffi::c_char =
    b"hello hello world\0" as *const u8 as *const ffi::c_char;
#[no_mangle]
pub static mut global_const_str_concatenation: [ffi::c_char; 18] = unsafe {
    *::core::mem::transmute::<&[u8; 18], &[ffi::c_char; 18]>(b"hello hello world\0")
};
#[no_mangle]
pub unsafe extern "C" fn test_fn_macro(mut x: ffi::c_int) -> ffi::c_int {
    return x * x;
}
#[no_mangle]
pub unsafe extern "C" fn reference_define() -> ffi::c_int {
    let mut x: ffi::c_int = 1 as ffi::c_int;
    x += 2 as ffi::c_int;
    if (3 as ffi::c_int) < (2 as ffi::c_int + 1 as ffi::c_int) * 3 as ffi::c_int
    {
        x += (2 as ffi::c_int + 1 as ffi::c_int) * 3 as ffi::c_int;
    }
    return x;
}
#[no_mangle]
pub static mut fns: fn_ptrs = {
    let mut init = fn_ptrs {
        v: 0 as *const ffi::c_void as *mut ffi::c_void,
        fn1: None,
        fn2: None,
    };
    init
};
#[no_mangle]
pub static mut p: *const fn_ptrs = unsafe { &fns as *const fn_ptrs };
#[no_mangle]
pub unsafe extern "C" fn test_zstd() -> U64 {
    return (if ::core::mem::size_of::<zstd_platform_dependent_type>() as ffi::c_ulong
        == 4 as ffi::c_ulong
    {
        30 as ffi::c_int
    } else {
        31 as ffi::c_int
    }) as U64;
}
#[no_mangle]
pub unsafe extern "C" fn stmt_expr_inc() -> ffi::c_int {
    let mut a: ffi::c_int = 0 as ffi::c_int;
    let mut b: *mut ffi::c_int = &mut a;
    ({
        *b += 1;
        *b;
        *b;
        *b
    });
    return ({
        *b += 1;
        *b;
        *b
    });
}
#[no_mangle]
pub unsafe extern "C" fn test_switch(mut x: ffi::c_int) -> ffi::c_int {
    match x {
        1 => return 10 as ffi::c_int,
        2 => return 20 as ffi::c_int,
        _ => {}
    }
    return 0 as ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn test_silk_int16_MIN() -> ffi::c_int {
    let mut _null: ffi::c_char =
        (*::core::mem::transmute::<&[u8; 1], &[ffi::c_char; 1]>(b"\0"))[(0x8000
            as ffi::c_int
            as ffi::c_short
            as ffi::c_int
            + 0x8000 as ffi::c_int)
            as usize];
    return 0x8000 as ffi::c_int as ffi::c_short as ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn use_extern_value() -> ffi::c_int {
    return extern_fn();
}
#[no_mangle]
pub unsafe extern "C" fn local_fn() -> ffi::c_int {
    return 1234 as ffi::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn use_local_value() -> ffi::c_int {
    return local_fn();
}
unsafe extern "C" fn run_static_initializers() {
    global_static_const_ptr_arithmetic = (b"hello\0" as *const u8 as *const ffi::c_char)
        .offset(5 as ffi::c_int as isize)
        .offset(-(3 as ffi::c_int as isize));
    global_static_const_indexing =
        (*::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0"))
            [3.14f64 as ffi::c_int as usize];
    global_static_const_ref_indexing = &*(b"hello\0" as *const u8 as *const ffi::c_char)
        .offset(3.14f64 as ffi::c_int as isize)
        as *const ffi::c_char;
    global_static_const_ternary = if 1 as ffi::c_int != 0 {
        1 as ffi::c_int
    } else {
        2 as ffi::c_int
    };
    global_static_const_member = {
        let mut init = S { i: 5 };
        init
    }
    .i;
    global_const_ptr_arithmetic = (b"hello\0" as *const u8 as *const ffi::c_char)
        .offset(5 as ffi::c_int as isize)
        .offset(-(3 as ffi::c_int as isize));
    global_const_indexing =
        (*::core::mem::transmute::<&[u8; 6], &[ffi::c_char; 6]>(b"hello\0"))
            [3.14f64 as ffi::c_int as usize];
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
