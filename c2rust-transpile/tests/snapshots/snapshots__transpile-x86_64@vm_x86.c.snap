---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/arch-specific/vm_x86.x86_64.rs
input_file: c2rust-transpile/tests/snapshots/arch-specific/vm_x86.c
---
#![allow(
    dead_code,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    path_statements,
    unsafe_op_in_unsafe_fn,
    unused_assignments,
    unused_mut,
    unused_unsafe,
    unused_variables
)]
#![feature(asm)]
use core::arch::asm;
use core::ffi;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vm_t {
    pub programStack: ffi::c_int,
    pub entryOfs: ffi::c_int,
    pub dataBase: *mut ffi::c_void,
    pub codeBase: *mut ffi::c_void,
    pub instructionPointers: *mut ffi::c_ulong,
}
unsafe impl Sync for vm_t {}
pub type byte = ffi::c_uchar;
pub const MAX_VMMAIN_ARGS: ffi::c_int = 50 as ffi::c_int;
#[unsafe(no_mangle)]
pub unsafe extern "C" fn VM_CallCompiled(
    mut vm: *mut vm_t,
    mut args: *mut ffi::c_int,
) -> ffi::c_int {
    let mut stack: [byte; 271] = [0; 271];
    let mut entryPoint: *mut ffi::c_void = 0 as *mut ffi::c_void;
    let mut programStack: ffi::c_int = 0;
    let mut stackOnEntry: ffi::c_int = 0;
    let mut image: *mut byte = 0 as *mut byte;
    let mut opStack: *mut ffi::c_int = 0 as *mut ffi::c_int;
    let mut opStackOfs: ffi::c_int = 0;
    let mut arg: ffi::c_int = 0;
    let mut currentVM: *mut vm_t = vm;
    stackOnEntry = (*vm).programStack;
    programStack = stackOnEntry;
    image = (*vm).dataBase as *mut byte;
    programStack -= 8 as ffi::c_int + 4 as ffi::c_int * MAX_VMMAIN_ARGS;
    arg = 0 as ffi::c_int;
    while arg < MAX_VMMAIN_ARGS {
        *(&raw mut *image.offset((programStack + 8 as ffi::c_int + arg * 4 as ffi::c_int) as isize)
            as *mut byte as *mut ffi::c_int) = *args.offset(arg as isize);
        arg += 1;
    }
    *(&raw mut *image.offset((programStack + 4 as ffi::c_int) as isize) as *mut byte
        as *mut ffi::c_int) = 0 as ffi::c_int;
    *(&raw mut *image.offset(programStack as isize) as *mut byte as *mut ffi::c_int) =
        -(1 as ffi::c_int);
    entryPoint = ((*vm).codeBase).offset((*vm).entryOfs as isize);
    opStack =
        ((&raw mut stack).cast::<byte>() as *mut ffi::c_int).offset(16 as ffi::c_int as isize);
    *opStack = 0 as ffi::c_int;
    opStackOfs = 0 as ffi::c_int;
    asm!(
        "movq [{2}], %rax\n", "movq [{0}], %r8\n", "movq [{1}], %r9\n", "push %r15\n",
        "push %r14\n", "push %r13\n", "push %r12\n", "callq *%rax\n", "pop %r12\n",
        "pop %r13\n", "pop %r14\n", "pop %r15\n", "\n", "mov {restmp0:x}, %bx\n", in
        (reg) & (* vm).instructionPointers, in (reg) & (* vm).dataBase, in (reg) &
        entryPoint, restmp0 = inlateout(reg) opStackOfs, inlateout("di") opStack,
        inlateout("si") programStack, out("rax") _, out("rcx") _, out("rdx") _, out("r8")
        _, out("r9") _, out("r10") _, out("r11") _, options(att_syntax)
    );
    if opStackOfs != 1 as ffi::c_int || *opStack as ffi::c_uint != 0xdeadbeef as ffi::c_uint {
        return 0 as ffi::c_int;
    }
    if programStack != stackOnEntry - (8 as ffi::c_int + 4 as ffi::c_int * MAX_VMMAIN_ARGS) {
        return 0 as ffi::c_int;
    }
    (*vm).programStack = stackOnEntry;
    return *opStack.offset(opStackOfs as isize);
}
