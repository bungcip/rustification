---
source: c2rust-transpile/tests/snapshots.rs
expression: cat tests/snapshots/arrays.rs
input_file: c2rust-transpile/tests/snapshots/arrays.c
---
#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    path_statements,
    unsafe_op_in_unsafe_fn,
    unused_assignments,
    unused_mut,
    unused_unsafe,
    unused_variables
)]
use core::ffi;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub y: ffi::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub x: *mut ffi::c_char,
    pub y: ffi::c_int,
}
unsafe impl Sync for C2RustUnnamed_0 {}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub x: ffi::c_short,
    pub y: ffi::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub x: ffi::c_short,
    pub y: ffi::c_int,
}
static mut simple: [ffi::c_char; 9] =
    unsafe { *::core::mem::transmute::<&[u8; 9], &mut [ffi::c_char; 9]>(b"mystring\0") };
static mut foo: *mut ffi::c_char = c"mystring".as_ptr() as *mut ffi::c_char;
#[unsafe(no_mangle)]
pub unsafe extern "C" fn entry() {
    let mut arr: [[ffi::c_int; 1]; 1] = [[1 as ffi::c_int]];
    arr[0 as ffi::c_int as usize][0 as ffi::c_int as usize] += 9 as ffi::c_int;
    let mut arr2: [ffi::c_int; 16] = [0; 16];
    arr2[15 as ffi::c_int as usize] += 9 as ffi::c_int;
    let mut arr3: [C2RustUnnamed_0; 1] = [C2RustUnnamed_0 {
        x: 0 as *mut ffi::c_char,
        y: 0,
    }; 1];
    arr3[0 as ffi::c_int as usize].y += 9 as ffi::c_int;
    let mut arr4: [ffi::c_int; 16] = [0 as ffi::c_int; 16];
    arr4[15 as ffi::c_int as usize] += 9 as ffi::c_int;
    let mut arr5: [C2RustUnnamed; 1] = [{
        let mut init = C2RustUnnamed { y: 1 as ffi::c_int };
        init
    }];
    arr5[0 as ffi::c_int as usize].y += 9 as ffi::c_int;
    let mut arr6: [ffi::c_int; 2] = [1 as ffi::c_int, 2 as ffi::c_int];
    let mut arr7: [ffi::c_int; 0] = [0; 0];
    let mut abc: [ffi::c_char; 4] =
        *::core::mem::transmute::<&[u8; 4], &mut [ffi::c_char; 4]>(b"abc\0");
    let mut def: [ffi::c_char; 3] = [
        'd' as i32 as ffi::c_char,
        'e' as i32 as ffi::c_char,
        'f' as i32 as ffi::c_char,
    ];
    let mut part: [ffi::c_char; 2] = [1 as ffi::c_int as ffi::c_char, 0];
    let mut abcptr: *mut ffi::c_char = c"abc".as_ptr() as *mut ffi::c_char;
    let mut init: [ffi::c_char; 5] =
        *::core::mem::transmute::<&[u8; 5], &mut [ffi::c_char; 5]>(b"abcd\0");
    let mut too_long: [ffi::c_char; 3] =
        *::core::mem::transmute::<&[u8; 3], &mut [ffi::c_char; 3]>(b"abc");
    let mut too_short: [ffi::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [ffi::c_char; 20],
    >(b"abc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0");
    let mut past_end: *mut ffi::c_char = &raw mut *(&raw mut simple)
        .cast::<ffi::c_char>()
        .offset(::core::mem::size_of::<[ffi::c_char; 9]>() as isize)
        as *mut ffi::c_char;
    past_end = &raw mut *foo.offset(8 as ffi::c_int as isize) as *mut ffi::c_char;
}
#[unsafe(no_mangle)]
pub unsafe extern "C" fn short_initializer() {
    let mut empty_brackets: [ffi::c_int; 16] = [0; 16];
    let mut brackets_with_zero: [ffi::c_int; 16] = [0 as ffi::c_int; 16];
    let mut brackets_with_one: [ffi::c_int; 4] = [1 as ffi::c_int, 0, 0, 0];
    let mut excess_elements_1: [ffi::c_int; 2] = [1 as ffi::c_int, 2 as ffi::c_int];
    let mut excess_elements_2: [ffi::c_int; 0] = [0; 0];
    let mut single_struct: [C2RustUnnamed_2; 1] = [{
        let mut init = C2RustUnnamed_2 {
            x: 1 as ffi::c_int as ffi::c_short,
            y: 2 as ffi::c_int,
        };
        init
    }];
    let mut many_struct: [C2RustUnnamed_1; 3] = [
        {
            let mut init = C2RustUnnamed_1 {
                x: 1 as ffi::c_int as ffi::c_short,
                y: 2 as ffi::c_int,
            };
            init
        },
        C2RustUnnamed_1 { x: 0, y: 0 },
        C2RustUnnamed_1 { x: 0, y: 0 },
    ];
}
